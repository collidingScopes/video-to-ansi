<!--
To do:
Use code page 437 font
Toggle for different char sets
Toggle for brightness threshold
Randomize inputs button
Export as image / video
Ability to accept user video input
More palettes
Entire UI should change color when palette is changed?
Footer / links div
Mobile testing
Responsive design that fits onto user device width/height size
Don't allow user slider for frame rate. Instead just render at the fastest frame rate we can, and display what that value is in the UI
Keyboard shortcut hotkeys
Toggle to invert charset
Add some randomness and glitches (matrix rain effect, etc.)
-->

<!DOCTYPE html>
<html>
<head>
    <title>ANSI TEXT CAMERA</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="container">
        <div class="header">
            <div class="header-left">
                <h1>ANSI TEXT CAMERA</h1>
            </div>
            <div class="header-right">
                <button id="playPause" class="terminal-button">‚èØ</button>
                <button class="terminal-button">üì∑</button>
                <button class="terminal-button">[TBD]</button>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>PALETTE:</label>
                <div class="select-wrapper">
                    <select id="paletteSelect" class="palette-select">
                        <option value="cyberpunk">CYBERPUNK</option>
                        <option value="anime">ANIME</option>
                        <option value="terminal">TERMINAL</option>
                        <option value="ibm">IBM</option>
                        <option value="retro">RETRO</option>
                        <option value="evangelion">EVANGELION</option>
                    </select>
                </div>
            </div>
            <div class="control-group">
                <label>FONT SCALE:</label>
                <input type="range" id="fontScale" min="100" max="300" value="140">
                <span id="fontScaleValue" class="value-display">1.4</span>
            </div>
            <div class="control-group">
                <label>RESOLUTION:</label>
                <input type="range" id="resolution" min="40" max="200" value="100">
                <span id="resValue" class="value-display">100x75</span>
            </div>
            <div class="control-group">
                <label>FRAMERATE:</label>
                <input type="range" id="fps" min="1" max="60" value="30">
                <span id="fpsValue" class="value-display">30</span>
            </div>
            <div class="control-group">
                <label>Invert: <input type="checkbox" id="invertCheckbox"> </label>
            </div>

        </div>

        <div id="viewport">
            <video id="video" autoplay playsinline width="640" height="480"></video>
            <canvas id="processCanvas"></canvas>
            <canvas id="outputCanvas"></canvas>
        </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 position;
        varying vec2 texCoord;
        void main() {
            texCoord = position * 0.5 + 0.5;
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 texCoord;
        uniform sampler2D uTexture;
        uniform vec2 uResolution;

        const vec3 luminanceWeights = vec3(0.299, 0.587, 0.114);

        vec4 sampleColor(vec2 pos) {
            vec4 color = texture2D(uTexture, pos);
            float luminance = dot(color.rgb, luminanceWeights);
            return vec4(color.rgb, luminance);
        }

        void main() {
            vec2 pixelSize = 1.0 / uResolution;
            vec2 cell = floor(texCoord / pixelSize) * pixelSize;
            
            vec4 totalColor = vec4(0.0);
            const float samples = 4.0;
            
            // 2x2 super-sampling
            for(float x = 0.25; x < 1.0; x += 0.5) {
                for(float y = 0.25; y < 1.0; y += 0.5) {
                    vec2 samplePos = cell + vec2(x, y) * pixelSize;
                    totalColor += sampleColor(samplePos);
                }
            }
            
            gl_FragColor = totalColor / samples;
        }
    </script>

    <script>
        // const ANSI_CHARS = " .'`^\",:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";
        const ANSI_CHARS = " .'`^\",:;¬∑-~=+|‚îÇ*‚ñ™‚óã‚ñë‚ñí‚ñì‚ñÑ‚ñÄ‚ñ†‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà";

        const COLOR_PALETTES = {
            cyberpunk: {
                primary: '#0ff',
                secondary: '#ff0',
                accent: '#f0f',
                highlight: '#fff',
                mid: '#0aa',
                dark: '#088',
                shadow: '#044',
                background: '#000'
            },
            anime: {
                primary: '#ffb7c5',
                secondary: '#0ff',
                accent: '#ffd700',
                highlight: '#fff',
                mid: '#ff69b4',
                dark: '#db7093',
                shadow: '#c71585',
                background: '#000'
            },
            terminal: {
                primary: '#0f0',
                secondary: '#f0f',
                accent: '#0ff',
                highlight: '#fff',
                mid: '#0a0',
                dark: '#080',
                shadow: '#040',
                background: '#000'
            },
            default: {
                bright_green: '#6f6',
                green: '#0f0',
                bright_cyan: '#6ff',
                cyan: '#0ff',
                bright_blue: '#66f',
                blue: '#00f',
                bright_magenta: '#f6f',
                magenta: '#f0f',
                white: '#fff',
                gray: '#666'
            },
            ibm: {
                primary: '#5DA5D5',
                secondary: '#3C4F65',
                accent: '#D0421B',
                highlight: '#fff',
                mid: '#4178BE',
                dark: '#2D3F4A',
                shadow: '#1D2529',
                background: '#000'
            },
            retro: {
                primary: '#83B799',
                secondary: '#EDB879',
                accent: '#D36135',
                highlight: '#E6E49F',
                mid: '#567568',
                dark: '#2E4052',
                shadow: '#1F2937',
                background: '#000'
            },
            evangelion: {
                primary: '#9B1F1F',
                secondary: '#4A138C',
                accent: '#FF6B00',
                highlight: '#fff',
                mid: '#731616',
                dark: '#350D0D',
                shadow: '#1A0606',
                background: '#000'
            },
        };

        let currentPalette = 'cyberpunk';

        class ANSIWebcam {
            constructor() {
                this.video = document.getElementById('video');
                this.processCanvas = document.getElementById('processCanvas');
                this.outputCanvas = document.getElementById('outputCanvas');
                this.resolutionSlider = document.getElementById('resolution');
                this.fpsSlider = document.getElementById('fps');
                this.playPauseBtn = document.getElementById('playPause');
                this.fontScaleSlider = document.getElementById('fontScale');
                this.invertCheckbox = document.getElementById('invertCheckbox');
                this.reversedChars = ANSI_CHARS.split('').reverse().join('');

                this.isPlaying = true;
                this.animationId = null;
                this.lastFrameTime = 0;
                this.frameInterval = 1000 / parseInt(this.fpsSlider.value);

                this.setupCanvas();
                this.setupWebGL();
                this.setupEventListeners();
            }

            setupCanvas() {
                const canvasSize = this.calculateCanvasSize();
                this.outputCanvas.width = canvasSize.width;
                this.outputCanvas.height = canvasSize.height;
                this.ctx = this.outputCanvas.getContext('2d', { 
                    alpha: false,
                    desynchronized: true
                });
                this.ctx.textBaseline = 'top';
                this.ctx.textAlign = 'center';

                // Set text rendering to optimize for dense character placement
                this.ctx.font = 'monospace';
                this.ctx.letterSpacing = '-1px';
                this.ctx.textRendering = 'optimizeLegibility';
            }

            calculateCanvasSize() {
                const padding = 100;
                const maxWidth = window.innerWidth - padding;
                const maxHeight = window.innerHeight - padding;
                const aspectRatio = 16 / 9;

                let width = maxWidth;
                let height = width / aspectRatio;

                if (height > maxHeight) {
                    height = maxHeight;
                    width = height * aspectRatio;
                }

                return { 
                    width: Math.floor(width), 
                    height: Math.floor(height) 
                };
            }

            setupWebGL() {
                this.gl = this.processCanvas.getContext('webgl', {
                    preserveDrawingBuffer: true,
                    antialias: false,
                    depth: false,
                    stencil: false
                });

                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }

                const vertexShader = this.createShader(
                    this.gl.VERTEX_SHADER,
                    document.getElementById('vertexShader').textContent
                );
                const fragmentShader = this.createShader(
                    this.gl.FRAGMENT_SHADER,
                    document.getElementById('fragmentShader').textContent
                );

                this.program = this.createProgram(vertexShader, fragmentShader);
                this.positionLocation = this.gl.getAttribLocation(this.program, 'position');
                this.resolutionLocation = this.gl.getUniformLocation(this.program, 'uResolution');

                // Create position buffer
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                const positionBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

                // Create and set up texture
                this.texture = this.gl.createTexture();
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    throw new Error(this.gl.getShaderInfoLog(shader));
                }

                return shader;
            }

            createProgram(vertexShader, fragmentShader) {
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    throw new Error(this.gl.getProgramInfoLog(program));
                }

                return program;
            }

            setupEventListeners() {

                document.getElementById('paletteSelect').addEventListener('change', (e) => {
                    currentPalette = e.target.value;
                });

                this.playPauseBtn.addEventListener('click', () => {
                    this.isPlaying = !this.isPlaying;
                    // this.playPauseBtn.textContent = this.isPlaying ? 'PAUSE' : 'PLAY';
                    if (this.isPlaying) {
                        this.video.play();
                        this.render();
                    } else {
                        this.video.pause();
                        if (this.animationId) {
                            cancelAnimationFrame(this.animationId);
                            this.animationId = null;
                        }
                    }
                });

                this.resolutionSlider.addEventListener('input', () => {
                    const width = parseInt(this.resolutionSlider.value);
                    const height = Math.floor(width * (this.processCanvas.height / this.processCanvas.width));
                    document.getElementById('resValue').textContent = `${width}x${height}`;
                });

                this.fpsSlider.addEventListener('input', () => {
                    document.getElementById('fpsValue').textContent = this.fpsSlider.value;
                    this.frameInterval = 1000 / parseInt(this.fpsSlider.value);
                });

                this.fontScaleSlider.addEventListener('input', () => {
                    const fontScale = this.fontScaleSlider.value / 100;
                    document.getElementById('fontScaleValue').textContent = fontScale.toFixed(1);
                });

                window.addEventListener('resize', () => {
                    clearTimeout(this.resizeTimeout);
                    this.resizeTimeout = setTimeout(() => {
                        location.reload();
                    }, 250);
                });
            }

            getColorForPixel(r, g, b) {
                const intensity = (r + g + b) / 3;
                const colorThreshold = 0.6;
                const palette = COLOR_PALETTES[currentPalette];

                // Color selection based on both intensity and color components
                if (intensity > 0.8) {
                    return palette.highlight;
                } else if (r > colorThreshold && g < colorThreshold && b < colorThreshold) {
                    return palette.accent;
                } else if (g > colorThreshold && r < colorThreshold && b < colorThreshold) {
                    return palette.secondary;
                } else if (b > colorThreshold && r < colorThreshold && g < colorThreshold) {
                    return palette.primary;
                } else if (intensity > 0.6) {
                    return palette.mid;
                } else if (intensity > 0.4) {
                    return palette.dark;
                } else if (intensity > 0.2) {
                    return palette.shadow;
                }
                return palette.background;
            }

            render = (currentTime) => {
                if (!this.isPlaying) return;
                this.animationId = requestAnimationFrame(this.render);

                if (currentTime - this.lastFrameTime < this.frameInterval) {
                    return;
                }
                this.lastFrameTime = currentTime;

                const width = parseInt(this.resolutionSlider.value);
                const height = Math.floor(width * (this.processCanvas.height / this.processCanvas.width));
                
                this.gl.viewport(0, 0, width, height);
                this.gl.useProgram(this.program);

                // Update texture with new video frame
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.video);

                this.gl.uniform2f(this.resolutionLocation, width, height);
                this.gl.enableVertexAttribArray(this.positionLocation);
                this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);

                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);

                // Read pixels (includes both color and brightness in alpha channel)
                const pixels = new Uint8Array(width * height * 4);
                this.gl.readPixels(0, 0, width, height, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);

                // Clear output canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
                
                // Calculate character dimensions
                const charWidth = (this.outputCanvas.width / width);
                const charHeight = this.outputCanvas.height / height;
                const fontScale = this.fontScaleSlider.value / 100;
                this.ctx.font = `${Math.min(charWidth, charHeight) * fontScale}px Font437 monospace`;
                // Render characters
                const currentChars = this.invertCheckbox.checked ? this.reversedChars : ANSI_CHARS;
            
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const r = pixels[i] / 255;
                        const g = pixels[i + 1] / 255;
                        const b = pixels[i + 2] / 255;
                        const brightness = pixels[i + 3] / 255; // Use pre-calculated brightness from shader
                        
                        const charIndex = Math.floor(brightness * (currentChars.length - 1));
                        this.ctx.fillStyle = this.getColorForPixel(r, g, b);
                        this.ctx.fillText(
                            currentChars[charIndex],
                            (x+0.5) * charWidth,
                            y * charHeight
                        );
                    }
                }
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 640 },
                            height: { ideal: 480 }
                        } 
                    });
                    
                    this.video.srcObject = stream;
                    await this.video.play();
                    
                    this.processCanvas.width = this.video.videoWidth;
                    this.processCanvas.height = this.video.videoHeight;
                    
                    this.render(0);
                    
                } catch (error) {
                    console.error('Error:', error);
                    this.ctx.fillStyle = '#f00';
                    this.ctx.fillText(
                        'Error accessing webcam. Please make sure you have a webcam connected and have granted permission to use it.',
                        this.outputCanvas.width / 2,
                        this.outputCanvas.height / 2
                    );
                }
            }
        }

        // Initialize and start the application
        const app = new ANSIWebcam();
        app.start();
    </script>
</body>
</html>